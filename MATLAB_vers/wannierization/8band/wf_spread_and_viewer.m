%% Wannier Function total Spread calculator
% checks the gauge and gauge-independent parts of the
% Wannier Function spread, Omega.
% Need to have "new_wf" files in the tar_folder.
% These are not included in the git repo, 
% they need to be generated by running tblg_wan_run.m

clear all;

tar_folder = 'run_folder_8band';
theta_list = 1.1;
%theta_lust = 0.6:.1:1.3;

theta_idx = 1;

for tar_theta = theta_list

    theta_str = strrep(num2str(tar_theta,'%.2f'),'.','p');
    
    wf_filename = [tar_folder '/eightWANnew_wf_' theta_str '_16k.mat'];
    load(wf_filename);
    %max(mmX(:))
    
    omega = 0;
    data_objs = {all_wfAL1, all_wfBL1, all_wfAL2, all_wfBL2};

    local_spread = zeros(8,1);
    for tar_wan = 1:8
        for subindex = 1:4
            wf_here = data_objs{subindex};
            spread_r2 = sum(sum(conj(wf_here(:,:,tar_wan)).*(mmX.^2 + mmY.^2).*wf_here(:,:,tar_wan)));
            spread_r = sum(sum(conj(wf_here(:,:,tar_wan)).*(mmX + mmY).*wf_here(:,:,tar_wan)));
            local_spread(tar_wan) = local_spread(tar_wan) + (spread_r2 - abs(spread_r)^2)/4;
            omega = omega + (spread_r2 - abs(spread_r)^2)/4;

        end
    end
    
    %%{
    %fprintf("--------\n");
    fprintf("Total Omega: %f \n", (real(omega)))

    sc_start = sc_grid1(1,1);
    sc_target = sc_start+1;
    [min, sc_end_idx] = min(abs(sc_grid1(1,:) - sc_target));

    sc_dgrid = sc_end_idx - 1;

    omega_gauge_dep = 0;
    for tar_wan = 1:8
        for subindex = 1:4
            wf_here = data_objs{subindex};
            for moire_dx = -1:1
                for moire_dy = -1:1
                    for tar_wan_2 = 1:8
                        wf_2_base = wf_here(:,:,tar_wan_2);
                        sc_x_basis = (1:size(sc_grid1,1));
                        sc_y_basis = (1:size(sc_grid1,2));

                        sc_x_basis = sc_x_basis + moire_dx*sc_dgrid;
                        sc_y_basis = sc_y_basis + moire_dy*sc_dgrid;

                        % basis elements that are non-zero for unshifted wf1
                        wf1_basis_here_x = sc_x_basis( and(sc_x_basis > 0, sc_x_basis < size(sc_grid1,1)+1));
                        wf1_basis_here_y = sc_y_basis( and(sc_y_basis > 0, sc_y_basis < size(sc_grid1,2)+1));

                        wf2_basis_here_x = wf1_basis_here_x - moire_dx*sc_dgrid;
                        wf2_basis_here_y = wf1_basis_here_y - moire_dy*sc_dgrid;


                        % skip the |Rm> = |0n> case
                        if (tar_wan ~= tar_wan_2 && ~( moire_dx ~= 0 && moire_dy ~= 0))
                            spread_r = sum(sum(conj(wf_2_base(wf2_basis_here_x,wf2_basis_here_y)).*(mmX(wf1_basis_here_x,wf1_basis_here_y) + mmY(wf1_basis_here_x,wf1_basis_here_y)).*wf_here(wf1_basis_here_x,wf1_basis_here_y,tar_wan)));
                            omega_gauge_dep = omega_gauge_dep + (abs(spread_r)^2)/4;
                        end
                    end
                end
            end
        end
    end

    fprintf("Gauge Omega: %f \n", (real(omega_gauge_dep)))
    fprintf("possible improvement in sqrt(Omega): \n %f Ang --> %f Ang \n", sqrt(real(omega)), sqrt(real(omega) - real(omega_gauge_dep)));
    fprintf("--------\n");
    %%}
    
    theta_spread(theta_idx,:) = abs(local_spread);
    theta_idx = theta_idx+1;
    
end


%% Wannier Function simple viewing script
% view |psi|^2 with layer/sublattice projection for different orbitals

clf
tar_orb = 1;
ax_m = 200;
c_max = 0.05;

for idx = 1:4
    subplot(2,2,idx)
    if (idx == 1)
        surf(mmX, mmY, abs(all_wfAL1(:,:,tar_orb)));
        title('L1 A')
    elseif (idx == 2)
        surf(mmX, mmY, abs(all_wfBL1(:,:,tar_orb)));  
        title('L1 B')
    elseif (idx == 3)
        surf(mmX, mmY, abs(all_wfAL2(:,:,tar_orb)));   
        title('L2 A')
    elseif (idx == 4)
        surf(mmX, mmY, abs(all_wfBL2(:,:,tar_orb)));  
        title('L2 B')
    end
    caxis([0 c_max])
    shading interp
    axis equal
    axis([-ax_m ax_m -ax_m ax_m 0 inf])
    view(2)
end


